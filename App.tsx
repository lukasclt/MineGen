
import React, { useState, useEffect, useRef } from 'react';
import { PluginSettings, GeneratedProject, ChatMessage, User, GitHubRepo, GeneratedFile } from './types';
import Sidebar from './components/ConfigSidebar';
import ChatInterface from './components/ChatInterface';
import CodeViewer from './components/CodeViewer';
import Terminal from './components/Terminal';
import AuthModal from './components/AuthModal';
import { DEFAULT_SETTINGS, getGithubWorkflowYml } from './constants';
import { getUserRepos, createRepository, getRepoFiles, getLatestWorkflowRun, getWorkflowRunLogs, commitToRepo } from './services/githubService';
import { playSound, speakText } from './services/audioService';
import { generatePluginCode } from './services/geminiService';

const App: React.FC = () => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [isAuthOpen, setIsAuthOpen] = useState(true);
  
  const [repos, setRepos] = useState<GitHubRepo[]>([]);
  const [currentRepo, setCurrentRepo] = useState<GitHubRepo | null>(null);
  const [isLoadingRepos, setIsLoadingRepos] = useState(false);
  
  const [projectData, setProjectData] = useState<GeneratedProject | null>(null); // Conteúdo atual (em memória)
  const [settings, setSettings] = useState<PluginSettings>(DEFAULT_SETTINGS);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [terminalLogs, setTerminalLogs] = useState<string[]>([]);
  
  // Build Loop State
  const [isBuilding, setIsBuilding] = useState(false);
  const [lastRunId, setLastRunId] = useState<number | null>(null);

  const addLog = (msg: string) => setTerminalLogs(prev => [...prev, msg]);

  // Carrega usuário do LocalStorage
  useEffect(() => {
     const saved = localStorage.getItem('minegen_user_github');
     if (saved) {
         setCurrentUser(JSON.parse(saved));
         setIsAuthOpen(false);
     }
  }, []);

  // Busca repositórios ao logar
  useEffect(() => {
     if (currentUser) {
         localStorage.setItem('minegen_user_github', JSON.stringify(currentUser));
         refreshRepos();
     }
  }, [currentUser]);

  const refreshRepos = async () => {
      if (!currentUser) return;
      setIsLoadingRepos(true);
      try {
          const data = await getUserRepos(currentUser.githubToken);
          setRepos(data);
      } catch (e) {
          addLog(`Erro ao buscar repos: ${e}`);
      } finally {
          setIsLoadingRepos(false);
      }
  };

  const handleCreateRepo = async () => {
      const name = prompt("Nome do Repositório:");
      if (!name || !currentUser) return;
      
      try {
          addLog("Criando repositório no GitHub...");
          const newRepo = await createRepository(currentUser.githubToken, name, "MineGen AI Project");
          setRepos(prev => [newRepo, ...prev]);
          setCurrentRepo(newRepo);
          
          // Commit Inicial com Template e Versão Java Dinâmica
          addLog(`Inicializando estrutura Gradle com Java ${settings.javaVersion} e Actions...`);
          const initialFiles: GeneratedFile[] = [
              { path: '.github/workflows/gradle.yml', content: getGithubWorkflowYml(settings.javaVersion), language: 'yaml' },
              { path: 'README.md', content: `# ${name}\n\nGenerated by MineGen AI`, language: 'text' }
          ];
          
          await commitToRepo(currentUser.githubToken, currentUser.username, name, initialFiles, "Initial commit", "Project scaffold");
          setProjectData({ explanation: "Projeto Iniciado", commitTitle: "Init", commitDescription: "", files: initialFiles });
          playSound('success');

      } catch (e: any) {
          alert("Erro: " + e.message);
      }
  };

  const handleSelectRepo = async (repo: GitHubRepo) => {
      setCurrentRepo(repo);
      setProjectData(null);
      setMessages([]);
      if (!currentUser) return;

      addLog(`Carregando arquivos de ${repo.name}...`);
      try {
          // Carrega arquivos da raiz
          const files = await getRepoFiles(currentUser.githubToken, repo.owner.login, repo.name, '');
          setProjectData({
              explanation: "Carregado do GitHub",
              commitTitle: "",
              commitDescription: "",
              files: files
          });
          // Tenta carregar src/main/java também para ter contexto
          try {
              const srcFiles = await getRepoFiles(currentUser.githubToken, repo.owner.login, repo.name, 'src/main/java');
              setProjectData(prev => prev ? ({ ...prev, files: [...prev.files, ...srcFiles] }) : null);
          } catch {}

      } catch (e) {
          addLog("Ainda não há arquivos neste repositório ou erro ao ler.");
      }
  };

  // --- BUILD LOOP LOGIC ---
  const handleCommitTriggered = () => {
      setIsBuilding(true);
      setLastRunId(null); // Reseta para buscar o novo
  };

  useEffect(() => {
      if (!isBuilding || !currentUser || !currentRepo) return;

      const interval = setInterval(async () => {
          try {
              const run = await getLatestWorkflowRun(currentUser.githubToken, currentRepo.owner.login, currentRepo.name);
              
              if (!run) return;

              // Se encontramos um run novo (ou o primeiro da sessão)
              if (lastRunId === null || run.id !== lastRunId) {
                  setLastRunId(run.id);
                  addLog(`GitHub Actions: Build iniciado (Run #${run.id})`);
              }

              if (run.status === 'completed') {
                  if (run.conclusion === 'success') {
                      setIsBuilding(false);
                      addLog(`✅ Build #${run.id} Sucesso!`);
                      playSound('success');
                      speakText("Build concluído com sucesso.");
                  } else if (run.conclusion === 'failure') {
                      setIsBuilding(false); // Para o polling, mas inicia a correção
                      addLog(`❌ Build #${run.id} Falhou. Iniciando auto-correção...`);
                      playSound('error');
                      handleAutoFix(run.id);
                  }
              }
          } catch (e) {
              console.error("Erro no polling de build", e);
          }
      }, 10000); // Check a cada 10s para não estourar rate limit

      return () => clearInterval(interval);
  }, [isBuilding, currentUser, currentRepo, lastRunId]);

  const handleAutoFix = async (runId: number) => {
      if (!currentUser || !currentRepo) return;
      
      try {
          addLog("Baixando logs do erro...");
          const logs = await getWorkflowRunLogs(currentUser.githubToken, currentRepo.owner.login, currentRepo.name, runId);
          
          const errorMsg: ChatMessage = {
              role: 'user',
              text: `O build falhou! Aqui estão os logs:\n\n${logs}\n\nCorrija o código.`,
              id: Date.now().toString()
          };
          setMessages(prev => [...prev, errorMsg]);
          
          addLog("IA analisando erro e gerando correção...");
          
          // Chama IA com o contexto do projeto atual + logs
          const fix = await generatePluginCode(errorMsg.text, settings, projectData, [], currentUser);
          
          addLog("Aplicando correção no GitHub...");
          await commitToRepo(
              currentUser.githubToken, 
              currentRepo.owner.login, 
              currentRepo.name, 
              fix.files, 
              fix.commitTitle || "Fix Build", 
              fix.commitDescription || "Auto-correction based on build logs"
          );
          
          const aiResponse: ChatMessage = {
              role: 'model',
              text: `Corrigi o erro: ${fix.explanation}. Novo build disparado.`,
              projectData: fix,
              id: Date.now().toString() + '_fix'
          };
          setMessages(prev => [...prev, aiResponse]);
          setProjectData(fix);
          
          // Reinicia o loop
          handleCommitTriggered();

      } catch (e: any) {
          addLog(`Falha na auto-correção: ${e.message}`);
      }
  };

  return (
    <div className="flex h-screen w-full bg-[#1e1e1e] text-[#cccccc] overflow-hidden">
      <AuthModal isOpen={isAuthOpen} onAuthSuccess={(u) => { setCurrentUser(u); setIsAuthOpen(false); }} />

      {currentUser && (
        <>
            <Sidebar 
                isOpen={sidebarOpen} toggleSidebar={() => setSidebarOpen(!sidebarOpen)}
                settings={settings} setSettings={setSettings}
                currentUser={currentUser} onLogout={() => { setCurrentUser(null); setIsAuthOpen(true); }}
                repos={repos} currentRepoId={currentRepo?.id || null}
                onSelectRepo={handleSelectRepo} onCreateRepo={handleCreateRepo}
                onRefreshRepos={refreshRepos} isLoadingRepos={isLoadingRepos}
            />

            <div className="flex-1 flex flex-col md:flex-row h-full min-w-0">
                <div className="flex-1 md:w-[35%] h-full flex flex-col min-w-0 border-r border-[#333]">
                    <ChatInterface 
                        settings={settings} messages={messages} setMessages={setMessages}
                        currentRepo={currentRepo} currentProject={projectData}
                        onProjectGenerated={setProjectData} currentUser={currentUser}
                        isBuilding={isBuilding} onCommitTriggered={handleCommitTriggered}
                    />
                </div>
                <div className="hidden md:flex flex-1 md:w-[65%] h-full flex-col min-w-0">
                    <CodeViewer 
                        project={projectData} settings={settings} 
                        directoryHandle={null} // Não usado mais
                        onAddToContext={() => {}} 
                    />
                    <Terminal logs={terminalLogs} isOpen={true} onClose={() => {}} onClear={() => setTerminalLogs([])} onAddLog={addLog} />
                </div>
            </div>
        </>
      )}
    </div>
  );
};

export default App;
